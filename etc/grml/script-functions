# Filename:      /etc/grml/script-functions
# Purpose:       some often used functions for use in shellscripts
# Authors:       grml-team (grml.org), (c) Michael Prokop <mika@grml.org>
# Bug-Reports:   see http://grml.org/bugs/
# License:       This file is licensed under the GPL v2.
# Latest change: Tue, 23 Oct 2007 16:53:48 +0200 [ft]
################################################################################

# {{{ set default PATH
setpath(){
  export PATH=${PATH:-'/bin:/sbin:/usr/bin:/usr/sbin:/usr/X11R6/bin:/usr/local/bin'}
}
# }}}

# {{{ check for root-permissions
check4root(){
  if [ "$(id -u 2>/dev/null)" != 0 ] ; then
    echo 1>&2 "Error: please run this script with uid 0 (root)." ; return 1
  fi
}
# }}}

# {{{ check for user permissions
check4user(){
  if [ "$(id -u 2>/dev/null)" = 0 ] ; then
    echo 1>&2 "Error: please do not run this script with uid 0 (root)." ; return 1
  fi
}
# }}}

# {{{ check for running zsh
iszsh(){
  if ! [ -z "$ZSH_VERSION" ] ; then
    return 0
  else
    return 1
  fi
}
# }}}

# {{{ check for (X)dialog
setdialog(){
  if [ -n "$DISPLAY" ] ; then
     [ -x /usr/bin/Xdialog ] && DIALOG="Xdialog" && export XDIALOG_HIGH_DIALOG_COMPAT=1
  else
     [ -x /usr/bin/dialog ] && DIALOG='dialog' || ( echo 1>&2 "dialog not available" ; return 1 )
  fi
}
# }}}

# {{{ check for availability of program(s)
check4progs(){
  local RC=''
  for arg in $* ; do
    type -p $arg >/dev/null 2>&1 || RC="$arg"
  done
  if [ -n "$RC" ] ; then
     echo "$RC not installed"
     return 1
  fi
}
# }}}

# {{{ simple shell grep
stringinfile(){
  case "$(cat $2)" in *$1*) return 0;; esac
  return 1
}
# }}}

# {{{ simple shell grep for strings
stringinstring(){
  case "$2" in *$1*) return 0;; esac
  return 1
}
# }}}

# {{{ reread boot command line; echo last parameter's argument or return false.
getbootparam(){
  stringinstring " $1=" /proc/cmdline || return 1
  result="${/proc/cmdline##*$1=}"
  result="${result%%[   ]*}"
  echo "$result"
  return 0
}
# }}}

# {{{ check boot commandline for specified option
checkbootparam(){
  stringinstring " $1" /proc/cmdline
  return "$?"
}
# }}}

# {{{ check whether $1 is yes
checkvalue(){
  if [ "$1" = "yes" -o "$1" = "YES" ] ; then
    return 0
  else
    return 1
  fi
}
# }}}

# {{{ grml specific checks
isgrml(){
  [ -f /etc/grml_version ] && return 0 || return 1
}

grmlversion(){
 cat /etc/grml_version
}

isgrmlcd(){
  [ -f /etc/grml_cd ] && return 0 || return 1
}

isgrmlhd(){
  [ -f /etc/grml_cd ] && return 1 || return 0
}

checkgrmlsmall(){
  grep -q small /etc/grml_version 2>/dev/null && return 0 || return 1
}
# }}}

# {{{ filesystems (proc, pts, sys)
mount_proc(){
  check4root || return 1
  [ -f /proc/version ] || mount -t proc /proc /proc 2>/dev/null
}

mount_pts(){
  check4root || return 1
  stringinfile "/dev/pts" /proc/mounts || mount -t devpts /dev/pts /dev/pts 2>/dev/null
}

mount_sys(){
  check4root || return 1
  [ -d /sys/devices ] || mount -t sysfs /sys /sys 2>/dev/null
}
# }}}

# char *reverse_list(list) {{{
#
#   Returns the reversed order of list
#
reverse_list() {
  local ret
  ret=''
  while [ "$#" -gt 0 ] ; do
    if [ -z "${ret}" ] ; then
      ret="$1"
    else
      ret="$1 ${ret}"
    fi
    shift
  done
  printf '%s' "${ret}"
}
#}}}

# bool is_older_than(reference, files/dirs to check) {{{
#
#   return 0 if any of the files/dirs are newer than
#   the reference file
#
#   EXAMPLE: if is_older_than a.out *.o ; then ...
is_older_than() {
  local x
  local ref="$1"
  shift

  for x in "$@" ; do
    [ "${x}" -nt "${ref}" ] && return 0

    if [ -d "${x}" ] ; then
      is_older_than "${ref}" "${x}"/* && return 0
    fi
  done

  return 1
}
#}}}

# e*() output functions {{{
# heavily based on gentoo's functions.sh; stripped down and modified
# to match our needs.
#
# defined functions:
#   ebegin()
#   eend()
#   eerror()
#   eindent()
#   einfo()
#   einfon()
#   eoutdent()
#   esetdent()
#   esyslog()
#   ewarn()
#   ewend()
#
# copyright 1999-2005 gentoo foundation
# distributed under the terms of the gnu general public license v2
# $header: /var/cvsroot/gentoo-src/rc-scripts/sbin/functions.sh,v 1.81.2.6 2005/05/15 20:00:31 vapier exp $

# initialisation {{{
# internal variables

# dont output to stdout?
rc_quiet_stdout="no"

# default values for e-message indentation and dots
rc_indentation=''
rc_default_indent=2
#rc_dot_pattern=' .'
rc_dot_pattern=''

# should we use color?
if [ -r /proc/cmdline ] ; then
  grep -q ' nocolor' /proc/cmdline && RC_NOCOLOR='yes'
fi
[ -n "$NOCOLORS" ] && RC_NOCOLOR='yes'
RC_NOCOLOR="${RC_NOCOLOR:-no}"

# Can the terminal handle endcols?
RC_ENDCOL="yes"

# Setup COLS and ENDCOL so eend can line up the [ ok ]
# width of [ ok ] == 7
COLS="$(stty size 2>/dev/null | cut -d' ' -f2)"
if [ -z "${COLS}" ] || [ "${COLS}" -le 0 ] ; then
  COLS=80
fi

if [ "${RC_ENDCOL}" = "yes" ]; then
  ENDCOL="[A[$(( ${COLS} - 8 ))G"
else
  ENDCOL=''
fi

# Setup the colors so our messages all look pretty
if [ "${RC_NOCOLOR}" = "yes" ]; then
  unset GOOD WARN BAD NORMAL HILITE BRACKET
else
  GOOD='[32;01m'
  WARN='[33;01m'
  BAD='[31;01m'
  NORMAL='[0m'
  HILITE='[36;01m'
  BRACKET='[34;01m'
fi
#}}}

# void esyslog(char* priority, char* tag, char* message)
#
#    use the system logger to log a message
#
esyslog() {
  local pri
  local tag

  [ "$#" -le 2 ] && return 0
  if [ -x /usr/bin/logger ] ; then
    pri="$1"
    tag="$2"
    shift 2

    /usr/bin/logger -p "${pri}" -t "${tag}" -- "$@"
  fi

  return 0
}

# void eindent(int num)
#
#    increase the indent used for e-commands.
#
eindent() {
  local i="${1:-0}"
  [ "$i" -gt 0 ] || i="${RC_DEFAULT_INDENT}"
  esetdent $(( ${#RC_INDENTATION} + $i ))
}

# void eoutdent(int num)
#
#    decrease the indent used for e-commands.
#
eoutdent() {
  local i="${1:-0}"
  [ "$i" -gt 0 ] || i="${RC_DEFAULT_INDENT}"
  esetdent $(( ${#RC_INDENTATION} - $i ))
}

# void esetdent(int num)
#
#    hard set the indent used for e-commands.
#    num defaults to 0
#
esetdent() {
  local i="${1:-0}"
  [ "$i" -lt 0 ] && i=0
  RC_INDENTATION="$(printf "%${i}s" '')"
}

# void einfo(char* message)
#
#    show an informative message (with a newline)
#
einfo() {
  einfon "$*\n"
  LAST_E_CMD=einfo
  return 0
}

# void einfon(char* message)
#
#    show an informative message (without a newline)
#
einfon() {
  [ "${RC_QUIET_STDOUT}" = "yes" ] && return 0
  [ "${RC_ENDCOL}" != "yes" ] && [ "${LAST_E_CMD}" = "ebegin" ] && echo
  printf " ${GOOD}*${NORMAL} ${RC_INDENTATION}$*"
  LAST_E_CMD=einfon
  return 0
}

# void ewarn(char* message)
#
#    show a warning message + log it
#
ewarn() {
  if [ "${RC_QUIET_STDOUT}" = "yes" ]; then
      printf " $*\n"
  else
    [ "${RC_ENDCOL}" != "yes" ] && [ "${LAST_E_CMD}" = "ebegin" ] && echo
    printf " ${WARN}*${NORMAL} ${RC_INDENTATION}$*\n"
  fi

  # Log warnings to system log
  esyslog "daemon.warning" "rc-scripts" "$@"

  LAST_E_CMD=ewarn
  return 0
}

# void eerror(char* message)
#
#    show an error message + log it
#
eerror() {
  if [ "${RC_QUIET_STDOUT}" = "yes" ]; then
    printf " $*\n" >/dev/stderr
  else
    [ "${RC_ENDCOL}" != "yes" ] && [ "${LAST_E_CMD}" = "ebegin" ] && echo
    printf " ${BAD}*${NORMAL} ${RC_INDENTATION}$*\n"
  fi

  # Log errors to system log
  esyslog "daemon.err" "rc-scripts" "$@"

  LAST_E_CMD=eerror
  return 0
}

# void ebegin(char* message)
#
#    show a message indicating the start of a process
#
ebegin() {
  local msg="$@" dots spaces
  spaces="$(printf '%'"${#RC_DOT_PATTERN}"'s' '')"
  [ "${RC_QUIET_STDOUT}" = "yes" ] && return 0

  if [ -n "${RC_DOT_PATTERN}" ]; then
    dots="$(printf "%$(( $COLS - 3 - ${#RC_INDENTATION} - ${#msg} - 7 ))s" '')"
    while [ "${dots#${spaces}}" != "${dots}" ] ; do
        dots="${dots#${spaces}}${RC_DOT_PATTERN}"
    done
    msg="${msg}${dots}"
  else
    msg="${msg} ..."
  fi
  einfon "${msg}"
  [ "${RC_ENDCOL}" = "yes" ] && echo

  LAST_E_LEN=$(( 3 + ${#RC_INDENTATION} + ${#msg} ))
  LAST_E_CMD=ebegin
  return 0
}

# void _eend(int error, char *efunc, char* errstr)
#
#    indicate the completion of process, called from eend/ewend
#    if error, show errstr via efunc
#
#    This function is private to functions.sh.  Do not call it from a
#    script.
#
_eend() {
  local retval="${1:-0}" efunc="${2:-eerror}" msg
  shift 2

  if [ "${retval}" -eq 0 ]; then
    [ "${RC_QUIET_STDOUT}" = "yes" ] && return 0
    msg="${BRACKET}[ ${GOOD}ok${BRACKET} ]${NORMAL}"
  else
    if [ "$#" -gt 0 ] ; then
        "${efunc}" "$@"
    fi
    msg="${BRACKET}[ ${BAD}!!${BRACKET} ]${NORMAL}"
  fi

  if [ "${RC_ENDCOL}" = "yes" ]; then
    printf "${ENDCOL}  ${msg}\n"
  else
    [ "${LAST_E_CMD}" = "ebegin" ] || LAST_E_LEN=0
    printf "%$(( ${COLS} - ${LAST_E_LEN} - 6 ))s%b\n" '' "${msg}"
  fi

  return "${retval}"
}

# void eend(int error, char* errstr)
#
#    indicate the completion of process
#    if error, show errstr via eerror
#
eend() {
  local retval="${1:-0}"
  shift

  _eend "${retval}" eerror "$@"

  LAST_E_CMD=eend
  return "$retval"
}

# void ewend(int error, char* errstr)
#
#    indicate the completion of process
#    if error, show errstr via ewarn
#
ewend() {
  local retval="${1:-0}"
  shift

  _eend "${retval}" ewarn "$@"

  LAST_E_CMD=ewend
  return "$retval"
}
#}}}

## END OF FILE #################################################################
# vim:foldmethod=marker tw=80 ai expandtab shiftwidth=2 tabstop=2
